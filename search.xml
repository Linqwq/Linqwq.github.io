<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[友链(洛谷)]]></title>
    <url>%2F2019%2F04%2F03%2F%E5%8F%8B%E9%93%BE-%E6%B4%9B%E8%B0%B7%2F</url>
    <content type="text"><![CDATA[以下都是各种大佬的友链(就我最菜了$qwq$) $AK KING$ 伤病都毁不掉的天才 $AK$ 虐全场 信竞体育两不误 文体两开花 $f AK e$大佬 神仙 又帅又强的巨佬(矩阵加速巨佬) 数据结构、模板神仙(目前$A$了45模板题)(模板随便刷，刷着玩) 喜捷捷(详见这里) 假装AFO大佬 书法家 早期UP主(打打广告：bilibili) 次机打县 艺术就是派大星 体育健将 杰伦的小粉丝 作死惨遭禁言的老哥 高一强者 强无敌 面向大海，春暖花开 全机房最强的人和他的小号(发明了一种美妙的算法，可是机房太小写不下，他给这个算法取了一个好听的名字：$ckttt$) 接下来是蒟蒻的友链 本蒟蒻的小号]]></content>
      <tags>
        <tag>友链</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF776B 【Sherlock and his girlfriend】]]></title>
    <url>%2F2019%2F03%2F30%2F%E9%A2%98%E8%A7%A3-CF776B-%E3%80%90Sherlock-and-his-girlfriend%E3%80%91%2F</url>
    <content type="text"><![CDATA[前言题目翻译有问题 Watson给Sherlock一个挑战：给这些珠宝首饰上色，当一件的价格是另一间的价格的因子时，使得这两件两件没有相同的颜色。此外，Watson要求他使用的尽量少种颜色。 其实应该是 Watson给Sherlock一个挑战：给这些珠宝首饰上色，当一件的价格是另一件的价格的质因子时，使得这两件首饰没有相同的颜色。此外，Watson要求他尽量使用少种颜色。 (错别字看着难受) 正题分析题目我们看一下数据大小 (标签)，$1&lt;=n&lt;=100000$，这不是可以写暴力吗？ 我们可以现在手动模拟一下 在理解一下题意并手动模拟一下后，不难发现只有在$n&lt;3$时颜色数为$1$，其余情况颜色数均为$2$(惊不惊喜，意不意外)。 快乐的分析代码时间12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#pragma GCC optimize(3)//O3优化#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;#define getchar() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1 &lt;&lt; 21, stdin), p1 == p2) ? EOF : *p1++)char buf[1 &lt;&lt; 21], *p1 = buf, *p2 = buf;template &lt; class T &gt; inline void read(T &amp;x) &#123; x = 0; char c = getchar(); bool f = 0; for (; !isdigit(c); c = getchar()) f ^= c == '-'; for (; isdigit(c); c = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (c ^ 48); x = f ? -x : x;&#125;#undef getchar()template &lt; class T &gt; inline void write(T x)&#123; if (x &lt; 0) putchar('-'), x = -x; if (x &gt; 9) write(x / 10); putchar(x % 10 + 48);&#125;//输入输出优化const ll FFF=1000000+5;ll n;ll ans=1;struct node&#123; ll price,color;&#125;zb[FFF];//price表示珠宝的价格，color表示珠宝的颜色//zb表示珠宝(拼音应该看得懂吧)bool isprime(int x)&#123; if(x==1) return false; if(x==2||x==3) return true; if(x%6!=1&amp;&amp;x%6!=5) return false; int s=sqrt(x); for(int i=5;i&lt;=s;i+=6) if(x%i==0||x%(i+2)==0) return false; return true;&#125;//(龟速)判断素数(想要快一点的话可以去学一学埃氏筛，MR等等快一点的筛法)int main()&#123; if(fopen("aaa.in", "r")) &#123; freopen("aaa.in", "r", stdin); freopen("aaa.out", "w", stdout); &#125; ios::sync_with_stdio(false);//关闭流同步，还是输入输出优化 read(n); for(int i=1;i&lt;=n;++i) &#123; zb[i].price=i+1; zb[i].color=1; &#125;//初始化，定义珠宝i的价格为i+1,颜色为1 for(int i=1;i&lt;=n/2;++i)//只需要从1搜索到n/2，因为n/2+1到n这个区间中是不可能互相为质因子的 &#123; if(isprime(zb[i].price)==true)//如果i是质数，那它可能是作为某一个数的质因子 &#123; ll now=1;//现在进行枚举，枚举一个数的质因子为zb[i].price，now表示倍数 while(now*zb[i].price&lt;=n+1)//如果枚举的数不大于n(即价格不大于n+1)，就说明zb[i].price是这个数的质因数 &#123; now+=1;//倍数+=1， zb[now*zb[i].price-1].color=zb[i].color==1?2:1;//zb[now*zb[i].price-1].color要与zb[i].color不同，所以当zb[i].color==1时zb[now*zb[i].price-1].color=2.否则zb[now*zb[i].price-1].color=1 &#125; &#125; &#125; write(n&lt;3?1:2);//根据上面的结论，当n&lt;3时输出1，否则输出2 putchar('\n'); for(int i=1;i&lt;=n;++i) &#123; write(zb[i].color);//输出第i个珠宝的颜色 putchar(' '); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P4305 【[JLOI2011]不重复数字】]]></title>
    <url>%2F2019%2F03%2F19%2F%E9%A2%98%E8%A7%A3-P4305-%E3%80%90-JLOI2011-%E4%B8%8D%E9%87%8D%E5%A4%8D%E6%95%B0%E5%AD%97%E3%80%91%2F</url>
    <content type="text"><![CDATA[前言题解中的各位神仙的$hash$、$map$、重载运算符等等的花里胡哨的东西，我看都看不懂,然后就自闭了，但其实这道题并不用这样写。 一个好习惯不管是考试还是自己刷题，先看一下数据范围 对于$100\%$的数据，$1 &lt;= N &lt;= 50000 $，给出的数在$ 32 $位有符号整数范围内。$ T≤50 $ 算一下，$N*T=2500000，$这不是随便跑吗，于是，我就开始入手 桶排$+$暴力。 介绍一下桶排 桶排序 $(Bucket sort)$或所谓的箱排序，是一个排序算法，工作的原理是将数组分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。桶排序是鸽巢排序的一种归纳结果。当要被排序的数组内的数值是均匀分配的时候，桶排序使用线性时间$（O（n））$。但桶排序并不是 比较排序，他不受到 $O(nlog_n)$ 下限的影响。 对于上图，$a$是原数列，在$a$的最大值是$9$,我们就开$9$个桶，第$i$的桶记录的是$i$在$a$中出现的次数，最后直接输出就好了。 但桶排并不是万能的，比如说下面这样一个数列$：”1,1,1,1,1,1,1,1,1,1,…,1,1e^9”$,中间有很多个$1$,最后一个$1e^9$，那这样按照桶排的方法的话，我们要开一个$1e^9$的桶，那就$MLE$了，这个时候就需要另一种排序方式了 基数排序 基数排序$（radix sort）$属于“分配式排序”$（distribution sort）$，又称“桶子法”$（bucket sort）$或$bin sort$，顾名思义，它是透过键值的部份资讯，将要排序的元素分配至某些“桶”中，藉以达到排序的作用，基数排序法是属于稳定性的排序，其时间复杂度为$O (nlog_r m)$，其中$r$为所采取的基数，而$m$为堆数，在某些时候，基数排序法的效率高于其它的稳定性排序法。 $P.S.$在排序时，本次处理必须和上次处理是稳定排序 稳定排序是什么呢？ 稳定排序 待排序的记录序列中可能存在两个或两个以上关键字相等的记录。排序前的序列中$R_i$领先于$R_j$（即$i&lt;j$）.若在排序后的序列中$R_i$仍然领先于$R_j$，则称所用的方法是稳定的。 即 处理次数$2$时有$”012”和”852”$这两个数，但由于在处理次数$1$时$”012”$在$”852”$的前面，所以基于稳定排序，在处理次数$2$时要把$”012”$放在$”852”$的前面，否则这就是不稳定排序。 关于这道题由于数据范围较小，所以我们可以桶排去写。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#pragma GCC optimize(3)#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const ll FFF=5e5+5;ll t,n;ll a[FFF],b[FFF];//a数组是原数组，b数组是桶数组bool flag[FFF];//flag记录该数是否输出过int main()&#123; //if(fopen(".in", "r")) //&#123; // freopen(".in", "r", stdin); // freopen(".out", "w", stdout); //&#125; ios::sync_with_stdio(false); cin&gt;&gt;t; for(int j=0;j&lt;t;++j) &#123; memset(flag,1,sizeof(flag));//初始化flag，1表示尚未输出，0表示已经输出 cin&gt;&gt;n; for(int i=1;i&lt;=n;++i) &#123; cin&gt;&gt;a[i];//输入原数组 b[a[i]]+=1;//并将原数组载入桶数组 &#125; for(int i=1;i&lt;=n;++i) &#123; if(b[a[i]]==1)//如果这个数只出现了一次 &#123; cout&lt;&lt;a[i]&lt;&lt;" ";//就直接输出 &#125; else//否则就需要去重操作 &#123; if(flag[a[i]]!=0)//如果这个数尚未输出 &#123; cout&lt;&lt;a[i]&lt;&lt;" ";//就输出一遍 flag[a[i]]=0;//并把flag即为0，表示已经输出过了 &#125; &#125; &#125; cout&lt;&lt;endl;//在两次询问之间要有换行 &#125; return 0;&#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1276 【校门外的树（增强版）】]]></title>
    <url>%2F2019%2F03%2F08%2F%E9%A2%98%E8%A7%A3-P1276-%E3%80%90%E6%A0%A1%E9%97%A8%E5%A4%96%E7%9A%84%E6%A0%91%EF%BC%88%E5%A2%9E%E5%BC%BA%E7%89%88%EF%BC%89%E3%80%91%2F</url>
    <content type="text"><![CDATA[首先提一下本题的几个容易忽略的坑点导致错误的地方吧1. 问最终校门外留下的树苗多少棵？ 是不是一开始看到时就不经过脑子的直接输出校门口的树的棵数啦(其实题目有说一开始就存在的是树，后面种下去的是树苗)(然后你就会获得80或者20分的好成绩)，可能只有我一个人看错了吧$QWQ$ 2. 植树者种上又被砍掉的树苗有多少棵？ 这个可能错的人比较少，它的意思是每逢砍树者把树苗砍了就把$ans++$，并不是在一个树坑中只能$ans++$一次 3. 校门外马路上本来从编号0到$L$，每一编号的位置都有1棵树。 把编号看错的应该不止我一个人吧(试图自我安慰) 终上所述，审题一定要好好审，不然原来完全对的程序也会爆零(我才不会告诉你我为了找出这些坑点给洛谷提供了一页的提交记录呢) 再养成一个好习惯做题前先看看一下数据的大小 这题的数据是$L（1 &lt;= L &lt;= 10000）$和 $N（1 &lt;= N &lt;= 100）$ 哎，$O(n^2)$的模拟好像可以$*$过去？ 那来吧，写模拟(可以写模拟的就不要写线段树了嘛，线段树那个码量不敢恭维) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#pragma GCC optimize(3)#include&lt;bits/stdc++.h&gt;#define ll long long//随手long long好习惯using namespace std;const ll FFF=10000+5;ll l,n;bool opt;//判断是砍树还是种树ll a,b;ll flag[FFF];//flag=1时是树(就是一开始就存在的)，flag=2时是树苗(就是后来种下的)，flag=0时是空气(空坑)ll ans_1,ans_2;//ans_1记录最终校门外留下的树苗棵数，ans_2记录植树者种上又被砍掉的树苗棵数int main()&#123; //if(fopen(".in", "r")) //&#123; // freopen(".in", "r", stdin); // freopen(".out", "w", stdout); //&#125; ios::sync_with_stdio(false);//关闭流同步，让cin、cout变得和scanf、printf一样快 cin&gt;&gt;l&gt;&gt;n; for(int i=0;i&lt;=l;++i)//记住编号从0开始，到l结束 &#123; flag[i]=1;//初始化，把树都种上 &#125; for(int i=0;i&lt;n;++i) &#123; cin&gt;&gt;opt&gt;&gt;a&gt;&gt;b; if(opt==0)//如果是砍树 &#123; for(int j=a;j&lt;=b;++j)//那就砍呗，从a到b &#123; if(flag[j]==2)//如果砍的是树苗 &#123; ans_2+=1;//ans_2++ &#125; flag[j]=0;//让flag=0，即记为空坑 &#125; &#125; else//如果是种树 &#123; for(int j=a;j&lt;=b;++j) &#123; if(flag[j]==0)//如果遇到一个空坑 &#123; flag[j]=2;//就把树苗种上，把flag变为2(注意，是树苗了，不能把flag变成1) &#125; &#125; &#125; &#125; for(int i=0;i&lt;=l;++i)//最后处理 &#123; if(flag[i]==2)//如果校门口有树苗的话 &#123; ans_1+=1;//ans_1++ &#125; &#125; cout&lt;&lt;ans_1&lt;&lt;endl&lt;&lt;ans_2;//输出，完结撒花 return 0;&#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF773D 【Perishable Roads】]]></title>
    <url>%2F2019%2F03%2F05%2F%E9%A2%98%E8%A7%A3-CF773D-%E3%80%90Perishable-Roads%E3%80%91%2F</url>
    <content type="text"><![CDATA[题目大意 附近有$n$个城市，城市两两之间都有双向的道路，道路的长度为$w$，某位旅行者的目的地是城市$s$，但是他不认路，所以他每到一个城市都会向那里的居民询问该往那里走才能到城市$s$，到一个城市的代价为所经过的道路的最小值，现在他想知道从任意一个城市出发到$s$的最小的代价和。他要去的城市$s$还没有定下来，所以请你求出对于所有的$s$的代价和。城市里的居民都很聪明，会对他指出使代价和最小的方案。 要部分分以及中文翻译的同学可以点开这里 出题人太菜了不知道什么部分分的算法，所以数据随机，并且给了正确性较高的乱搞部分分。 如果有用乱搞得到高分的选手可以先上来分享一下做法 题目分析我一开始的错误想法很显然，这个路标连接起来之后是一棵树，对于每一个城市的贡献就是这个城市到终点城市$s$的路上的最小值。 然后我就有了一个~~非常睿智的~~想法：就是对于任意一个终点城市$s$，把所有的城市都连在最短边的一端，再由最短边直接连到终点城市$s$。 ~~然后。。。这个东西显然是假的~~ 正确的想法不过我们可以考虑对它进行一些~~微$(jù)$小$(dà)$的~~修改让它成为正确的。 考虑这个想法的错误之处：在于最短边的一端到终点的距离可能很长， 所以我们考虑对这个进行计算 最短边的一边到终点城市的路径显然是一条链。 可以发现这条链如果是从终点城市开始递减的 那么答案就是这条链的长度 我们考虑把这个东西再转化一下 对于一个中间有边比之后的边要小的话，那么显然它之前的所有边直接连到最短边就好了。 那么这条最短边的贡献应该为两倍的权值 然后对于一个最短边的点到一个点的距离可以简化成本来存在的路或者是这个点连着一条边的两倍 然后以最短边的点为起点跑最短路就好了 最后记得加上剩下的边数乘最短边 献上我的丑陋码风代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;char gc()&#123; static char buf[1&lt;&lt;20],*p1=buf,*p2=buf; if(p1==p2) &#123; p2=(p1=buf)+fread(buf,1,1&lt;&lt;20,stdin); if(p1==p2)return EOF; &#125; return *p1++;&#125;#define getchar gctemplate&lt;typename _Tp&gt;_Tp read(_Tp&amp; x)&#123; x=0; char c=getchar(); while(c&lt;'0'||c&gt;'9')c=getchar(); while(c&gt;='0'&amp;&amp;c&lt;='9')x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); return x;&#125;using namespace std;long long n,s,ans,minn,a[5005][5005],dis[5005];bool vis[5005];inline void dijkstra(int s)&#123; memset(vis,0,sizeof(vis)); memset(dis,0x7f,sizeof(dis)); for(int i=1;i&lt;=n;i++) &#123; dis[i]=a[s][i]; for(int j=1;j&lt;=n;j++) &#123; if(i!=j)dis[i]=min(dis[i],a[i][j]*2); &#125; &#125; vis[s]=1; for(int i=1;i&lt;=n-1;i++) &#123; long long minn=~(1LL&lt;&lt;63),v; for(int j=1;j&lt;=n;j++) &#123; if(!vis[j]&amp;&amp;dis[j]&lt;minn) &#123; minn=dis[j];v=j; &#125; &#125; vis[v]=true; for(int j=1;j&lt;=n;j++) &#123; if(!vis[j]) &#123; dis[j]=min(dis[j],dis[v]+a[v][j]); &#125; &#125; &#125;&#125;int main()&#123; read(n); minn=0x7fffffffffffffff; for(int i=1;i&lt;=n-1;i++) &#123; for(int j=i+1;j&lt;=n;j++) &#123; read(a[i][j]); a[j][i]=a[i][j]; if(a[i][j]&lt;minn)minn=a[i][j],s=i; &#125; &#125; for(int i=1;i&lt;=n-1;i++) &#123; for(int j=i+1;j&lt;=n;j++) &#123; a[i][j]-=minn; a[j][i]=a[i][j]; &#125; &#125; dijkstra(s); for(int i=1;i&lt;=n;i++) &#123; printf("%lld ",dis[i]+minn*(n-1)); &#125;&#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF632F 【Magic Matrix】]]></title>
    <url>%2F2019%2F03%2F04%2F%E9%A2%98%E8%A7%A3-CF632F-%E3%80%90Magic-Matrix%E3%80%91%2F</url>
    <content type="text"><![CDATA[暴力当看到$n≤2500$和5000ms/512MB的时空限制时， 我就想到 开花 暴力(看到iki9奆佬的暴力之后，我深深地感受到了我是多么地菜) 这道题的暴力其实比较好打，按着题意打就可以了， 我的是 $ O(n^3) $ 暴力，所以我的暴力这道题并过不去,那我打出来干什么呢？仅供欣赏，不做讲解(同样打 $ O(n^3) $ 暴力的同学可以去这里交一下，题目有一点小魔改，需要改一下程序的) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#pragma GCC optimize(3)#include&lt;bits/stdc++.h&gt;using namespace std;const int FFF=2500+5;int n;int a[FFF][FFF];int main()&#123; ios::sync_with_stdio(false); scanf("%d",&amp;n); for(int i=0;i&lt;n;++i) &#123; for(int j=0;j&lt;n;++j) &#123; scanf("%d",&amp;a[i][j]); &#125; &#125; for(int i=0;i&lt;n;++i) &#123; if(a[i][i]!=0) &#123; puts("NOT MAGIC"); return 0; &#125; &#125; for(int i=0;i&lt;n;++i) &#123; for(int j=0;j&lt;i+1;++j) &#123; if(i!=j) &#123; if(a[i][j]!=a[j][i]) &#123; puts("NOT MAGIC"); return 0; &#125; &#125; &#125; &#125; for(int i=0;i&lt;n;++i) &#123; for(int j=0;j&lt;n;++j) &#123; if(i!=j) &#123; for(int k=0;k&lt;n;++k) &#123; if(a[i][j]&gt;max(a[i][k],a[k][j])) &#123; puts("NOT MAGIC"); return 0; &#125; &#125; &#125; &#125; &#125; puts("MAGIC"); return 0;&#125; 应该是正解吧我们看一下本题的三个条件 对于每一个$i,j,a_{i,j}=a_{j,i}$(在矩阵中就是左下角的数和右上角的数对称相等) 对于每一个$i,a_{i,i}=0$(在矩阵中就是对角线都为 0) 对于每一个$i,j,k,a_{i,j}≥max(a_{i,k},a_{k,j})$(在矩阵中就是对于任意一个格子$(i,j)$要满足对于任意的 $k$,$a_{i,j}≥max(a_{i,k},a_{k,j})$,k 为$1$~$n$中的任意数，可以与$i,j$相等) 是不是看起来有一点眼熟？ $a_{i,j}=a_{j,i}$,表示无向图 $a_{i,i}=0$,表示无自环 $a_{i,j}≥max(a_{i,k},a_{k,j})$,表示最小生成树 所以，这道题可以用最小生成树去写。 复杂度$O(n^2)$,可以$*$过此题 具体写法第一个和第二个条件直接$O(n^2)$判断过去就好了，不表 我们重点讲然如何判断第三个条件(敲黑板) 怎么判断这个矩阵是不是最小生成树呢？ 我们先把它看做一个邻接矩阵， 建立一个完全图， 如果这个图是的任一个生成树都是最小生成树的话， 则满足题意，输出“MAGIC”。 那么重点在于如何去证明这个完全图的任一个生成树都是最小生成树。 我们可以看一下下面的图 如果$max(a,b)≤c$,那么如果按照最小生成树的方法，应该选择连接$B-A-C$才是正确的连法， 否则这个完全图就不满足题意了。 下面是判断第三个条件的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455for(int i=0;i&lt;n;++i)&#123; fa[i]=1; dis[i]=a[1][i];&#125;us[1]=1;while(true)&#123; j=-1; for(int i=0;i&lt;n;++i) &#123; if(!us[i]&amp;&amp;(j==-1||dis[i]&lt;dis[j])) &#123; j=i; &#125; &#125; if(j==-1) &#123; break; &#125; us[j]=1; for(int i=0;i&lt;n;++i) &#123; if(!us[i]&amp;&amp;a[j][i]&lt;dis[i]) &#123; dis[i]=a[j][i]; fa[i]=j; &#125; &#125;&#125;d[1]=1;for(int i=0;i&lt;n;++i)&#123; if(!d[i]) &#123; getf(i); &#125; &#125;for(int i=0;i&lt;n;++i)&#123; for(int j=i+1; j&lt;=n; j++) &#123; x=i; y=j; if(d[y]&gt;d[x]) &#123; swap(x,y); &#125; if(a[x][y]&gt;a[fa[x]][x]&amp;&amp;a[x][y]&gt;a[fa[x]][y]) &#123; printf("NOT MAGIC"); return 0; &#125; &#125;&#125; 献上我丑陋的AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#pragma GCC optimize(3)#include&lt;bits/stdc++.h&gt;using namespace std;const int L=1000000;char LZH[L];char *SSS,*TTT;inline char gc()&#123; if (SSS==TTT) TTT=(SSS=LZH)+fread(LZH,1,L,stdin); return *SSS++;&#125;inline int read()&#123; int x=0; char c=gc(); for (;c&lt;'0'||c&gt;'9';c=gc()); for (;c&gt;='0'&amp;&amp;c&lt;='9';c=gc()) x=(x&lt;&lt;1)+(x&lt;&lt;3)+c-48; return x;&#125;template &lt; class T &gt; inline void write(T x)&#123; if (x &lt; 0) putchar('-'), x = -x; if (x &gt; 9) write(x / 10); putchar(x % 10 + 48);&#125;const int FFF=2500+5;int n,j,x,y,a[FFF][FFF],fa[FFF],us[FFF],dis[FFF],d[FFF];void getf(int x)&#123; if(!d[fa[x]])getf(fa[x]); d[x]=d[fa[x]]+1;&#125;int main()&#123; n=read(); for(int i=0;i&lt;n;++i) &#123; for(int j=0;j&lt;n;++j) &#123; a[i][j]=read(); if(i==j&amp;&amp;a[i][j]！=0) &#123; puts("NOT MAGIC"); return 0; &#125;//判断第一个条件 if(i&gt;j&amp;&amp;a[i][j]！=a[j][i]) &#123; puts("NOT MAGIC"); return 0; &#125;//判断第二个条件 &#125; &#125; for(int i=0;i&lt;n;++i) &#123; fa[i]=1; dis[i]=a[1][i]; &#125; us[1]=1; while(true) &#123; j=-1; for(int i=0;i&lt;n;++i) &#123; if(!us[i]&amp;&amp;(j==-1||dis[i]&lt;dis[j])) &#123; j=i; &#125; &#125; if(j==-1) &#123; break; &#125; us[j]=1; for(int i=0;i&lt;n;++i) &#123; if(!us[i]&amp;&amp;a[j][i]&lt;dis[i]) &#123; dis[i]=a[j][i]; fa[i]=j; &#125; &#125; &#125; d[1]=1; for(int i=0;i&lt;n;++i) &#123; if(!d[i]) &#123; getf(i); &#125; &#125; for(int i=0;i&lt;n;++i) &#123; for(int j=i+1; j&lt;=n; j++) &#123; x=i; y=j; if(d[y]&gt;d[x]) &#123; swap(x,y); &#125; if(a[x][y]&gt;a[fa[x]][x]&amp;&amp;a[x][y]&gt;a[fa[x]][y]) &#123; printf("NOT MAGIC"); return 0; &#125; &#125; &#125; puts("MAGIC"); return 0;&#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P2451 【[SDOI2005]遗传代码】]]></title>
    <url>%2F2019%2F02%2F21%2F%E9%A2%98%E8%A7%A3-P2451-%E3%80%90-SDOI2005-%E9%81%97%E4%BC%A0%E4%BB%A3%E7%A0%81%E3%80%91%2F</url>
    <content type="text"><![CDATA[安利一下本蒟蒻的博客 题意就是说第一行读入一个数$n$， 从第二行到第$n+1$行，每行读入两个数，分别是$l,r$， 你需要在这$2n$个数中找到一个最短的数列（题目中的遗传代码）使得在这个数列中的任意一个元素$a[i]=l[j]$，且$a[i+1]=r[j]$ ($j&lt;=n$) 题目分析当我们看到$l，r$这个范围的时候$（1 &lt;= l &lt;= 1000, 1 &lt;= r &lt;= 1000）$，我就想到了暴力 树 好的，让我们开始吧。 用$tl$数组记录$l$出现的次数，用$tr$数组记录$r$出现的次数, 记录初始答案$ans$为$n$， 如果出现了多余的l或r（即$tl&gt;tr$时）， 就可以让$ans$减去$tl-tr$, 最后输出$ans$就好了 题目的一个小小小的坑点 在primitivus的遗传代码中没有(p,p)特征。(题目原话) 什么意思呢？就是说如果$r[i]=l[l+1]$，那么$l[i],r[i],l[i+1],r[i+1]$只能算3个 具体栗子 如输入样例中的 122 33 99 68 55 77 64 55 11 44 22 88 6 $(2,8),(8,6)$在遗传代码中只能算成$(2,8,6)$三个数(在输出样例的说明中可以看出来$(8, 5, 1, 4, 2, 3, 9, 6, 4, 5, 7, 6, 2, 8, 6)$) 核心模板 存入$tr,tl$数组 123456for(int i=0;i&lt;n;++i)&#123; cin&gt;&gt;l[i]&gt;&gt;r[i]; tl[l[i]]++; tr[r[i]]++;&#125; $tl[l[i]]$是指$l[i]$出现的次数； $tr[r[i]]$是指$r[i]$出现的次数； 处理 1234567for（int i=1;i&lt;1000+1;++i）&#123; if（tr[i]&gt;tl[i]） &#123; sum+=tr[i]-tl[i]; &#125;&#125; 如果$tr[i]&gt;tl[i]$，也就是上文所说的多余的$l$和$r$(因为$l$和$r$是一一对应的) 最终的代码1234567891011121314151617181920212223242526272829303132333435#pragma GCC optimize(3)#include&lt;bits/stdc++.h&gt;using namespace std;const int FFF=6666;int n,l[FFF],r[FFF];int tl[FFF],tr[FFF];int maxx;int sum;int main()&#123;// freopen(".in","r",stdin);// freopen(".out","w",stdout); ios::sync_with_stdio(false); cin&gt;&gt;n; for(int i=0;i&lt;n;++i) &#123; cin&gt;&gt;l[i]&gt;&gt;r[i]; tl[l[i]]++; tr[r[i]]++; &#125; for（int i=1;i&lt;1000+1;++i） &#123; if（tr[i]&gt;tl[i]） &#123; sum+=tr[i]-tl[i]; &#125; &#125; cout&lt;&lt;sum+n; return 0;&#125;]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些并不是洛谷题的题解（栈，队列）]]></title>
    <url>%2F2019%2F02%2F17%2F%E4%B8%80%E4%BA%9B%E5%B9%B6%E4%B8%8D%E6%98%AF%E6%B4%9B%E8%B0%B7%E9%A2%98%E7%9A%84%E9%A2%98%E8%A7%A3%EF%BC%88%E6%A0%88%EF%BC%8C%E9%98%9F%E5%88%97%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目 1. 翻栈(U62970)(stack.cpp,1000ms,128MB) 题目描述 栈有 push,pop,top 三个操作。现在加入一种 reverse 操作，表示把栈中所有元素的顺序翻转。 输入描述 一个数 n 表示操作数量。接下来 n 行，每行有”push”,”pop”,”top”,”reverse”中的一种。其中，push 后有一个整数表示插入的数值。 输出描述 对于每个 top 输出一行一个整数表示当前栈顶元素。对于每个 top/pop，如果当前的栈已经为空，输出一行’Empty!’（不含引号）。 输入样例 5poppush 10push 6reversetop 输出样例 Empty!10 数据范围及提示 对于 30%的数据，n&lt;=1000对于另 20%的数据，没有 reverse 操作对于所有数据，n&lt;=10^5，1&lt;=栈中元素&lt;=10^6 2. 填写逻辑(U62971)(exp.cpp,1000ms,128MB) 题目描述 现在有一个逻辑式，但是逻辑式中的数值被吃了，只剩下括号和运算符。已知逻辑式的结果为 False，求有多少种可能的数值填写。其中&amp;表示逻辑中的 and，|表示 or。注意，运算顺序为先算括号内，再算&amp;，再算|。 输入描述 一行一个字符串，仅包含’(‘，’)’，‘&amp;’，‘|’，保证合法。 输出描述 一行一个整数，表示填写数值的方案数，对 10007 取模。 输入样例 (|)&amp; 输出样例 5 数据范围及描述 对于 30%的数据，输入长度&lt;=10对于 60%的数据，输入长度&lt;=200对于另 20%的数据，保证没有括号对于所有数据，输入长度&lt;=3*10^5 对于样例 ( _ | _ ) &amp; _ 当填写方案为(0,0,0)(1,0,0)(0,1,0)(1,1,0)(0,0,1)时，逻辑式结果为 False。注意：(())合法；不会出现诸如(|)(&amp;)的不合法情况 3. 滑稽树前做游戏，滑稽树后做交易(U62974)(trade.cpp,500ms,512MB) 题目描述 滑稽果被排成一列，‘老板’要求每个顾客只能买一段连续的区间。某个神仙OIer来这里买滑稽果，他对每个滑稽果都有一个喜爱程度 Ai 是一个整数，-100≤Ai≤100，并保证∑Ai &lt;=2147483647，最终的满意度为所有他买到的滑稽果的喜欢程度之和，如果和为正（不管是正多少，只要大于 0 即可），则他满意了。现在神仙OIer想知道在他满意的条件下最多能买到多少滑稽果。 输入描述 第一行一个正整数 n，表示‘老板’一共摘了 n 个滑稽果。第二行 n 个整数，每个整数 Ai 表示 sxd 第 i 个滑稽果的喜爱程度为多少。 输出描述 一行一个正整数 ans 表示在神仙OIer满意的条件下最多能买到多少滑稽果 输入样例 50 0 -7 -6 1 输出样例 1 数据范围及提示 对于 30%的数据，n&lt;=5*10^3 对于 60%的数据，n&lt;=10^5 请注意本题的内存限制，完成代码后请务必计算一下你程序的内存是否超限。 其实原来这道题有4个数据是大数据，但由于洛咕咕咕的数据上传zip的大小不能超过20M，所以就上传不了啦 对于原来所有数据，n&lt;=3*10^7对于这种数据，不用快读快写是卡不过去的 两个快读快写模板 fastIO.cpp(注意，只能用freopen读入)12345678910111213141516171819202122inline char gc()&#123; static char buf[1&lt;&lt;12],*p1=buf,*p2=buf; return (p1==p2)&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;12,stdin),p1==p2)?EOF:*p1++;&#125;#define dd c = gc()inline int read()&#123; static int x; x = 0; int dd; bool f = false; for(; !isdigit(c); dd) if(c == '-') f = true; for(; isdigit(c); dd) x = (x&lt;&lt;1) + (x&lt;&lt;3) + (c^48); if(f) x = -x; return x;&#125;#undef dd 一个正常的快读快写模板(就是可以不用freopen读入的)123456789101112131415template&lt;class T&gt;void read(T&amp; x)&#123; x=0; bool f=0; char c=getchar(); while(c&lt;48||c&gt;57)f|=(c=='-'),c=getchar(); while(c&gt;=48&amp;&amp;c&lt;=57)x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); x=f?~x+1:x;&#125;inline void write(int x)&#123; if(x&lt;0) putchar('-'),x=-x; if(x&gt;9) write(x/10); putchar(x%10+'0');&#125; 下面是队列，双端队列，栈，取出最大值或取出最小值的优先队列的一些基本操作123456789deque&lt;int&gt; que //双端队列que.push_front()//从队首插入que.pop_front()//弹出队首que.push_back()//从队尾插入que.pop_back()//弹出队尾que.empty()//判断是否为空que,空que时返回trueque.size()//que的大小que.front()//队首que.back()//队尾 123456stack&lt;int&gt; st //栈st.push(x)//入stst.pop()//弹stst.top()//st顶st.empty()//判断是否为空st,空st时返回truest.size()////st的大小 1234567queue&lt;int&gt; que //队列que.push()//入队que.pop()//出队que.front()//队首que.back()//队尾que.empty()//判断是否为空que,空que时返回trueque.size()//que的大小 1234567priority_queue&lt;int&gt; que//取出最大值的优先队列priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; que//取出最小值的优先队列que.push()//入堆que.pop()//出堆que.top//堆顶que.empty()//判断是否为空堆，空堆时返回trueque.size()//堆的大小 题解(带标程)1. 翻栈(stack)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105/*这道题其实就是栈的基本操作加上一个翻转栈的操作，翻转栈时，可以先不用直接翻转，而是记录下来；因为翻转双数次等于没有翻转；不过对于每一次操作都要多进行一次判断*/#pragma GCC optimize(3)#include&lt;bits/stdc++.h&gt;using namespace std;const unsigned long long FFF=1e6+5;const unsigned long long fff=0x7fffffff;unsigned long long n;char a[FFF];//字符串unsigned long long x;deque&lt;int&gt; que;//双端队列bool alrev;//alrev用来记录翻转，如果翻转了两次就等于没有翻转，//但是每次操作都要进行判断；//如果alrev为1，就要倒过来操作void re()&#123; alrev^=1;//翻转一次就对alrev取反一次&#125;void pu(int x)//对应put&#123; if(alrev==0)//进行判断，如果尚未翻转 &#123; que.push_back(x);//就从队列的左端插入 &#125; else//如果翻转过了 &#123; que.push_front(x);//就从队列的右端插入 &#125;&#125;void po()//对应pop&#123; if(que.empty())//判断是否为空队列，如果是 &#123; cout&lt;&lt;"Empty!"&lt;&lt;endl;//就直接输出Empty return;//并return，结束这次操作 &#125; if(alrev==0)//已知que不是空队列了，再判断是否翻转过了，如果尚未翻转 &#123; que.pop_back();//就弹出队列的最左端 &#125; else//如果翻转过了 &#123; que.pop_front();//就弹出队列的最右端 &#125;&#125;int to()//对应top，注意是int型函数&#123; if(que.empty())//判断是否为空队列，如果是 &#123; cout&lt;&lt;"Empty!"&lt;&lt;endl;//就直接输出Empty return fff;//并return一个值，结束这次操作 &#125; if(!alrev)//已知que不是空队列了，再判断是否翻转过了，如果尚未翻转 &#123; return que.back();//就return队列的最左端 &#125; return que.front();//否则return队列的最右端 &#125;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;n; for(unsigned long long i=1;i&lt;=n;++i) &#123; cin&gt;&gt;a; //不需要进行完全的字符串的对比，只需要对比让a[0]，a[1]与po,pu,re,to进行比较 // if(a[1]=='p'&amp;&amp;a[2]=='u')//注意,字符串是从0位开始的，所以从a[0]开始 if(a[0]=='p'&amp;&amp;a[1]=='u')//如果操作是push，还需要读入一个数x &#123; cin&gt;&gt;x; pu(x);//并把x插入队列 continue; &#125; // if(a[1]=='p'&amp;&amp;a[2]=='o') if(a[0]=='p'&amp;&amp;a[1]=='o') &#123; po(); continue; &#125; // if(a[1]=='r'&amp;&amp;a[2]=='e') if(a[0]=='r'&amp;&amp;a[1]=='e') &#123; re(); continue; &#125; // if(a[1]=='t'&amp;&amp;a[2]=='o') if(a[0]=='t'&amp;&amp;a[1]=='o') &#123; int top_num=to();//定义一个数来记录top操作的返回值 if(top_num!=fff)//如果top_num并不是我们之前设置的那个数的话 &#123; cout&lt;&lt;top_num&lt;&lt;endl;//就输出top_num，也就是to()函数的返回值，也就是队列的最左或最右端 &#125; //如果是top_num是我们之前设置的那个数的话，就说明这是一个空队列 //就直接continue就好了 continue; &#125; &#125; return 0;&#125; 2. 填写逻辑(exp)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109/*洛谷原话，搬运过来。原题 P1310 表达式的值 这道题是一道表达式计算的拓展题，其核心的部分就是表达式计算。 此题需要使用两个栈，一个存放结果，另一个存放符号。每次读入一个数据，就进入结果栈，如果是符号，则按以下方法： 1、如果是左括号，就直接进栈； 2、如果是右括号，就一直弹栈并加以计算，直到弹到左括号； 3、如果是运算符，则弹栈，直到这个运算符的优先级大于符号栈栈顶的符号的优先级 或是左括号 或是栈空，然后将运算符进栈；这道题的运算是有规律的 设两个步骤的运算结果经过每个符号到一个结果时，第一个运算结果算出0的方案数为lf,1的方案数为lt,第二个算出0的方案数为rf，算出1的方案数为rt，则有： 当符号是“|”时，得到0的方案数为lf*rf%P,1的方案数：(lt*rf%P+lf*rt%P+lt*rt%P)%P 当符号是“&amp;”时，得到0的方案数为lt*rf%P+lf*rt%P+lf*rf%P)%P,1的方案数：lt*rt%P 用一个栈记录下来即可 (摘自洛谷) */#pragma GCC optimize(3)#include&lt;bits/stdc++.h&gt;using namespace std;const int INF=1e6+5;// const long long inflonglong=0x7fffffffffffffff;const int FFF=1e5+5;const int P=10007;//模数int n;char zf[3*INF];//字符char op;//记录符号栈的top stack&lt;int&gt; st_1;stack&lt;int&gt; st_2;//两个栈stack&lt;char&gt; ss;//符号栈nt lt,lf,rt,rf;//就是上面说的那个，第一个运算结果计算出0的方案数为lf,计算出1的方案数为lt,第二个计算出0的方案数为rf，计算出1的方案数为rtint i;void calc()//计算&#123; lt=st_1.top(); lf=st_2.top(); st_1.pop(); st_2.pop(); rt=st_1.top(); rf=st_2.top(); st_1.pop(); st_2.pop(); op=ss.top(); ss.pop(); //运算规则就是上面说的那个规律 if(op=='&amp;') &#123; st_1.push(lt*rt%P); st_2.push((lt*rf%P+lf*rt%P+lf*rf%P)%P); &#125; else &#123; st_1.push((lt*rf%P+lf*rt%P+lt*rt%P)%P); st_2.push(lf*rf%P); &#125;&#125;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;zf; int i; for(i=0;zf[i];++i)//因为是字符串，所以从0位开始 &#123; if(zf[i]!='('&amp;&amp;(i?zf[i-1]!=')':true)) //三目运算符，如果i！=0，就返回true //如果i=0且zf[i-1]!=')' //就返回true //否则返回false &#123; st_1.push(1); st_2.push(1);//存入 1 &#125; switch(zf[i])//对zf[i]进行分类讨论 &#123; case('&amp;'): while((!ss.empty())&amp;&amp;ss.top()=='&amp;') //如果符号栈不是空栈且栈顶是&amp; &#123; calc();//计算 &#125; ss.push('&amp;');//把&amp;插入符号栈 break; case('|'): while((!ss.empty())&amp;&amp;(ss.top()=='&amp;'||ss.top()=='|'))//如果符号栈不是空栈且栈顶是&amp;或| &#123; calc(); &#125; ss.push('|'); break; case('('): ss.push('('); break; case(')'): while(ss.top()!='(')//如果栈顶不是（ &#123; calc(); &#125; ss.pop();//弹出栈顶 ('(') break; &#125; &#125; if(zf[i-1]!=')')//如果符号是) &#123; st_1.push(1); st_2.push(1);//就插入 1 &#125; while(!ss.empty())//如果符号栈不是空栈 &#123; calc();//就一直计算直到空栈 &#125; cout&lt;&lt;st_2.top();//输出是表达式的值为0的方案数 return 0;&#125; 3. 滑稽树前做游戏，滑稽树后做交易(trade)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/*这道题的主要思路是:先计算前缀和，让maxx[n]=sum[n];然后从后面开始进行遍历，计算出每一个i的最大前缀和maxx[i]=max(maxx[i+1],sum[i])再进行区间伸缩*/#pragma GCC optimize(3)#include&lt;bits/stdc++.h&gt;using namespace std;inline char gc()&#123; static char buf[1&lt;&lt;12],*p1=buf,*p2=buf; return (p1==p2)&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;12,stdin),p1==p2)?EOF:*p1++;&#125;#define dd c = gc()inline int read()&#123; static int x; x = 0; int dd; bool f = false; for(; !isdigit(c); dd) if(c == '-') f = true; for(; isdigit(c); dd) x = (x&lt;&lt;1) + (x&lt;&lt;3) + (c^48); if(f) x = -x; return x;&#125;#undef ddconst int INF=1e7+5;const int FFF=3*INF;int n,ans,a[FFF];int sum[FFF];//前缀和int maxx[FFF];//最大前缀和int main()&#123; ios::sync_with_stdio(false); n=read(); // cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) &#123; a[i]=read(); // cin&gt;&gt;a[i]; &#125; for(int i=1;i&lt;=n;i++) &#123; sum[i]=sum[i-1]+a[i];//计算第i项的前缀和 &#125; maxx[n]=sum[n];//先定义第n项的最大前缀和是是第n项的前缀和 for(int i=n-1;i&gt;=1;--i)//要从后面开始遍历 &#123; maxx[i]=max(maxx[i+1],sum[i]);//再计算i项的最大前缀和 &#125; for(int hd=1,tl=1;hd&lt;=n&amp;&amp;tl&lt;=n;hd++,tl++)//开始区间伸缩 &#123; if(maxx[tl]&lt;=sum[hd-1])//如果tl的最大前缀和不大于hd-11的最大前缀和的话 //那么hd到tl的区间并不是最优解 //所以可以直接continue; &#123; continue; &#125; while(maxx[tl]&gt;sum[hd-1]&amp;&amp;tl&lt;=n)//如果tl的最大前缀和大于hd-11的最大前缀和且tl比n小 &#123; ++tl;//就将tl向右移一位 //继续进行区间伸缩 &#125; ans=max(ans,tl-hd);//用ans记录最长的区间 &#125; cout&lt;&lt;ans; return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>杂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P3367 【【模板】并查集】]]></title>
    <url>%2F2019%2F02%2F14%2F%E9%A2%98%E8%A7%A3-P3367-%E3%80%90%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E5%B9%B6%E6%9F%A5%E9%9B%86%E3%80%91%2F</url>
    <content type="text"><![CDATA[前言这道题是一道对初学者有点不太友好的题目，因为一开始可能有点难理解（理解之后可能还好），可是这道题又是一道初学者必须码的一道题（比如说我这种蒟蒻） 题意我们先理解一下题意，题目提供了两个正整数$n$，$m$,表示有$n$个元素，$m$次询问。接着他给了你$m$行询问，一行询问有$z$,$x$,$y$三个数。当$z$=1时，将$x$与$y$所在的集合合并;当$z$=2时，输出$x$与$y$是否在同一集合内，是的话输出$Y$；否则话输出$N$。 核心模板 找爸爸 $f[x]$是指$x$的爸爸（P.S. 一开始每个元素的爸爸就是它自己） 123456789101112int find(int x) &#123; if(f[x]==x)//如果一个元素的爸爸就是它自己 &#123; return x;//就直接返回它自身 &#125; else &#123; f[x]=find(f[x]);//否则就接下去寻找，直到找到他的爸爸为止 &#125; return f[x];//返回它的爸爸的值 &#125; 合并（就是当z=1时） 1234void work1(int x,int y) &#123; f[find(y)]=find(x); &#125; 合并的本质就是使$x$和$y$的爸爸变成同一个爸爸（逃 $find(x)$是找到$x$的爸爸，$f[find(y)]$是找到$y$爸爸的爸爸（它的祖先？雾。。。）并使他们相等，也就是让$x$和$y$的集合合并。 原理见图： 从图中可以看出，合并之后$x$和$y$就成为了兄弟，也就是在同一个集合内了（集合合并） 查询（也就是当z=2的时候） 1234567891011void work2(int x,int y)//查询 &#123; if(find(x)==find(y))//查询是否为同一个爸爸 &#123; cout&lt;&lt;"Y"&lt;&lt;endl;//是就输出“Y” &#125; else &#123; cout&lt;&lt;"N"&lt;&lt;endl;//不是就输出“N” &#125; &#125; 如果$x$和$y$的爸爸是同一个的话，那么$x$和$y$就是兄弟，也就是说$x$和$y$在同一集合中，所以输出$Y$，不然就输出$N$。 把以上模板拼接一下，就是AC代码啦 #pragma GCC optimize(3)//O3优化不用管啦 #include&lt;bits/stdc++.h&gt; using namespace std; int n,m,z[666666],x[666666],y[666666]; int f[666666]; int find(int x)//找爸爸 { if(f[x]==x) { return x; } else { f[x]=find(f[x]); } return f[x]; } void work1(int x,int y)//合并 { f[find(y)]=find(x); } void work2(int x,int y)//查询 { if(find(x)==find(y)) { cout&lt;&lt;&quot;Y&quot;&lt;&lt;endl; } else { cout&lt;&lt;&quot;N&quot;&lt;&lt;endl; } } int main() { // freopen(&quot;.in&quot;,&quot;r&quot;,stdin); // freopen(&quot;.out&quot;,&quot;w&quot;,stdout); ios::sync_with_stdio(false);//关闭同步使cin，cout变快 cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=m;i++) { cin&gt;&gt;z[i]&gt;&gt;x[i]&gt;&gt;y[i]; f[i]=i; } for(int i=1;i&lt;=m;i++) { if(z[i]==1) { work1(x[i],y[i]); } else { work2(x[i],y[i]); } } return 0;//完结撒花 }]]></content>
      <tags>
        <tag>洛谷</tag>
        <tag>题解</tag>
      </tags>
  </entry>
</search>
